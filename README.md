# 📌 15분식탁 (Paws Time)

> 자취생과 1인 가구를 위한  
> **15분 이내 · 저비용 레시피 공유 & 커뮤니티 서비스**

---

## 📖 목차
- [🍳 프로젝트 소개](#-프로젝트-소개)
- [✨ 핵심 기능 & 언어](#-핵심-기능-언어)
- [👥 팀원 소개](#-팀원-소개)
- [🤝 협업 방식](#-협업-방식)
- [🔍 브랜치 전략](#-브랜치-전략)
- [⚡ 아키텍처 개요](#-아키텍처-개요)
- [🧱 기술 스택](#-기술-스택)
- [⚙ 배포](#-배포)
- [🖥 화면 구현](#-화면-구현)

---

## 🍳 프로젝트 소개

**15분식탁**은  
자취생과 1인 가구를 위한  
**15분 이내 · 저비용 레시피 공유 서비스**입니다.

복잡한 조리 과정과 긴 요리 시간을 줄이고,  
누구나 부담 없이 집밥을 즐길 수 있도록  
레시피 공유와 커뮤니티 기능을 중심으로 설계되었습니다.

### ✨ 핵심 컨셉
- ⏱️ 15분 이내 조리 기준
- 💰 저비용 재료 중심
- 🍽️ 자취생 맞춤 집밥
- 💬 레시피 중심 커뮤니티
---

## ✨ 핵심 기능

- 레시피 작성 / 수정 / 조회
- 댓글, 북마크, 마이페이지
- 커뮤니티 게시판
- 카카오맵 기반 주변 마트 / 편의점 탐색
- AI 해시태그 자동 추천
- JWT 기반 인증 / 인가
- 관리자 페이지 실시간 관리
- 팔로워 팔로잉 / 실시간 알림 기능

- 메인 언어 & 배포

- [![My Skills](https://skillicons.dev/icons?i=js,html,css,react)](https://skillicons.dev)

- [![My Skills](https://skillicons.dev/icons?i=spring,mysql,postman)](https://skillicons.dev)

- [![My Skills](https://skillicons.dev/icons?i=github,docker,notion)](https://skillicons.dev)
- ![lombok](https://camo.githubusercontent.com/90664690f2b5f02dda8335c4b5a3d7a61720a800d4892ac4ff301807ea5839e0/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6f6d626f6b2d6361303132343f7374796c653d666f722d7468652d6261646765266c6f676f3d646174613a696d6167652f706e673b6261736536342c6956424f5277304b47676f414141414e53556845556741414145414141414241434159414141437161584865414141414358424957584d41414173544141414c457745416d7077594141414565456c45515652346e4f32615734685656526a48503031487a5a4a474a63707555366c303055717a676c347343727167447a35495a5a6a5a51786c45614b424a575641397045454733516b714553727441715768592b5744515a42704632797331444c7a30733373707155324e722f34324776523139655a6156707a4274615a733339776d4c50503376732f612b3231396e64625336536b704b536b704b536b3167454f413134482f6742756b586f446d4d48667643663142484155384c313541484f6c6e6741654e4a332f4175677639514977416a686f4873416b715365416c30336e56307450416a67447542743445396749744141586d2f4e6e41573268382f7233484f6b4a414b63456c7859375a316c6d726e76452f4c356365674c414a4741666c546b453347437533576e4f6651794d6c466f476d42773647576b466c6f5466547763476d577348564868417677446a70525942546e4d6a2f326c48377a5177744a315a7368633455326f4e594958722f4f424f684c37376a5148556a6b632b4148704c7251434d63752f35325a32383730567a333362674e334e387464514b7750326d3455762f7833306e416476436661384339786964743652576f4168664978506475614f426463416d6638376b415a634268775048474e657073364642636763595a7a722f4d3944506e5a2f6d6a4e7a7a51464d48656c2b6161302b55334145576d415976726e422b6d4f74556449383635613848526f645a6f6c356b69764d6b78306e4f414c32417265314e66335064494f437064694c44396d6a4e506973454c75316f2b6c65342f6f4977386e3932346746384b4c6b447244514e66694d594c763362397a2f7561774a7544706e67326d42453156442b615052756c4272772f5732687354716933356e476a30725130396b522b516b594b446b444c44494e667439382f77726f6b364333324767736c4a79686d4d4b32696d4f742f4b77455066554342384c394f717447534d34414c356b4f662b594d345a454a65764f4d5272506b444444654e4c624e6a663738424c32427747366a4d55467968534b442b386730647233352f71754773676d617334314753395a5a494958726976774f374448486479546f6156486b57364d78575849464f44574d637552646c386f4f534e43636154512b7958623067623468594c47757a6b5a7a3179566f39676432475931724a4665412b31794d72694d6557613035515263742f3261314c354b783154396b4776754f4d33784e435a724458416e734b736b52594c687a555330756f30754b313445586a4d62624b544f6f327745476879704f5a49387a6773324a55332b693064435a4e555a79412b67487244454e33653865686872426f516d366a5734783543484a44614350466a5a4e4933584b4c33502b6632786938555272415a48507451346f4f514530414b2f77542b34456e6a504830784b3162334e54503638564941712f764e78312f6f6c77376e6a674d5742366f7659567758314737704b636f45684956726e4f50316d4e7372532b4c73376c4e576356385647457542746335316546616271784b2b2b7072673236537048714e556f7555437849324952476d512b385a6f37505464512b442f6a42364879744b304753417851572b58595834576d4635365a772f7679513969354b4356474271634662524c354a71524e323536616b4e5737556458517572494b32707265504f753174575a53344b507a37624463794d62592f746772366c7742626e4c59575445366f54672b3662756a5775636131687665396f51726c38615556566e32657a6d4a6c68364c69616e64687867304959377567325674336534574644622f4b6f2f2f7257736b46696d31714e7161666d316933312f6637497541425941662f52682f454d38415179516e675764504965304e43596a39486d4443344d645438645550546c634374774d4d685a5931312b306f6458354b4e6c666341632b676531484d733149636c4f514d4d63535773564e7243586a376433486835746957735367416e6835305a4f384d4b725033456a556b4877764857454c4c7139746248517859334953582f4c796b704b536b704b5a48753543382b45545264752b3544364141414141424a52553545726b4a6767673d3d266c6f676f436f6c6f723d7768697465)
---

## 👥 팀원 소개

| 이름 | 역할 | GitHub |
|---|---|---|
| 심재원 | 팀장 / Backend & Frontend | https://github.com/S-JaeWon |
| 배찬익 | 팀원 /Backend & Frontend| https://github.com/dgf0020 |
| 홍해준 | 팀원 /Backend & Frontend | https://github.com/ |

---

## 🤝 협업 방식

#### ❇️**역할 분리 기반 협업**

- Notion 기반 요구사항 및 기획 정리
- GitHub Issue 기반 작업 관리
- 기능 단위 브랜치 생성 후 개발
- Pull Request + 코드 리뷰 후 병합
- Discord를 통한 실시간 커뮤니케이션

### 역할 분담
- **Frontend**
  - UI / UX 구현
  - API 연동 및 상태 관리
- **Backend**
  - REST API 설계
  - 인증 / 인가
  - DB 및 비즈니스 로직 구현
- **Desing**
  - pigma 디자인 구현 

---

## 🔍 브랜치 전략

본 프로젝트는 프론트엔드와 백엔드를 분리하여 개발하는 구조로,  
기능 단위 작업과 안정적인 병합을 위해 명확한 브랜치 전략을 사용하였다.

#### ❇️ 기본 브랜치 구성

- `main`
  - 항상 배포 가능한 상태를 유지하는 기준 브랜치
  - 모든 기능은 직접 커밋하지 않고 Pull Request를 통해서만 병합
  - 코드 리뷰가 완료된 작업만 반영하여 안정성을 유지

- `develop` (선택적 운영)
  - 여러 기능을 통합하여 테스트하기 위한 브랜치
  - 프로젝트 진행 상황에 따라 사용 여부를 결정
  - 필요 시 `main` 병합 전 중간 검증 용도로 활용

---

#### ❇️ 이슈 기반 브랜치 전략

- 모든 작업은 GitHub Issue 생성 후 시작한다.
- 하나의 이슈는 하나의 브랜치에서만 처리한다.
- 브랜치는 반드시 `main` 브랜치에서 분기하여 생성한다.
- 프론트엔드와 백엔드가 동시에 작업하는 기능의 경우,
  동일한 이슈를 기준으로 각 영역에서 브랜치를 분리하여 작업하였다.
- 이를 통해 기능 단위 개발과 병렬 작업 시 충돌을 최소화하였다.

---

#### ❇️ 브랜치 네이밍 방식 (설명)

브랜치 이름에는 작업의 성격과 작업 영역이 드러나도록 구성하였다.  
이를 통해 브랜치 이름만 보고도 어떤 작업인지 쉽게 파악할 수 있도록 하였다.

- 프론트엔드 브랜치
  - 화면(UI), 사용자 흐름, 관리자 페이지, 대시보드 시각화 등
    클라이언트 영역의 기능 구현을 담당
  - 주로 새로운 화면 추가 또는 UI 수정 작업에 사용

- 백엔드 브랜치
  - API 구현, 비즈니스 로직 처리, 관리자 통계 및 데이터 연산 기능을 담당
  - 프론트엔드 요구사항을 기반으로 API 구조를 설계하고 기능을 구현

- 브랜치에는 연결된 이슈 번호를 함께 포함하여,
  작업 내용과 이슈 추적이 자연스럽게 연결되도록 관리하였다.

---

#### ❇️ 브랜치 운영 원칙

- `main` 브랜치에는 직접 커밋하지 않는다.
- 하나의 브랜치에서는 하나의 작업 목적만 수행한다.
- 작업 완료 후에는 반드시 Pull Request를 생성하여 코드 리뷰를 진행한다.
- 리뷰가 완료된 코드만 병합하여 코드 품질과 안정성을 유지하였다.

---

#### ❇️**정기 회의 및 코드 리뷰**
 - **월요일**: 팀 회의를 통해 진행 상황 공유 및 문제 논의 & 주일간 예정 사항 정리<br>
 - **금요일**: 팀 회의를 통해 진행 상황 공유 및 문제 논의<br>
 - 프론트엔드는 UI를 시연, 백엔드는 API 및 기능 구현 리뷰.<br>
 - **스타일 및 규칙 정리**: 프론트엔드 컴포넌트 구조와 백엔드 레이어 구조를 유지하도록합의 반복되는 문제는 규칙으로 정리하어 이후 작업 반영

---

## ⚡아키텍처 개요

본 프로젝트는 프론트엔드와 백엔드를 분리한 구조로 설계하여  
역할 분담이 명확하고 유지보수가 용이하도록 구성하였다.

프론트엔드는 사용자 화면과 관리자 페이지를 담당하며,  
백엔드는 API 제공 및 비즈니스 로직 처리를 담당한다.  
양측은 REST API를 통해 통신하며, 각 영역은 독립적으로 개발 및 확장이 가능하다.

---

#### ❇️ 전체 구조

사용자 및 관리자는 프론트엔드 애플리케이션을 통해 서비스를 이용하며,  
프론트엔드는 필요한 데이터를 백엔드 서버에 API 요청 방식으로 전달한다.  
백엔드는 요청을 처리한 후 JSON 형태의 응답을 반환한다.

---

#### ❇️ 프론트엔드 아키텍처

- React 기반의 SPA 구조로 구성하였다.
- 페이지 단위와 컴포넌트 단위를 분리하여 역할을 명확히 하였다.
- API 요청 로직을 별도로 분리하여 화면 로직과 데이터 로직을 분리하였다.
- 관리자 페이지는 일반 사용자 화면과 분리하여 구성하였다.
- 상태 관리를 통해 사용자 인증 및 화면 상태를 일관되게 유지하였다.

---

#### ❇️ 백엔드 아키텍처

- Spring Boot 기반의 REST API 서버로 구성하였다.
- Controller / Service / Repository(Mapper) 계층 구조를 사용하였다.
- 비즈니스 로직과 데이터 접근 로직을 분리하여 유지보수성을 확보하였다.
- 관리자 기능 및 통계 기능은 일반 기능과 분리하여 관리하였다.
- MyBatis를 사용하여 SQL을 명확하게 관리하였다.

---

#### ❇️ 프론트엔드 ↔ 백엔드 연동 방식

- 프론트엔드는 Axios 기반의 HTTP 통신을 통해 백엔드 API를 호출한다.
- 백엔드는 REST API 형태로 데이터를 제공한다.
- 기능 단위로 API를 분리하여 프론트엔드와 백엔드 간 책임을 명확히 하였다.
- 관리자 대시보드와 같은 기능은 통계 전용 API를 통해 데이터를 제공받는다.

---

#### ❇️ 아키텍처 설계 의도

- 프론트엔드와 백엔드의 독립적인 개발 및 배포를 고려한 구조
- 역할 분리를 통해 협업 효율 및 코드 가독성 향상
- 관리자 기능 확장을 고려한 구조 설계
- 유지보수와 기능 확장에 유리한 계층 구조 유지

---

## 🛠 기술 스택

본 프로젝트는 프론트엔드와 백엔드를 분리한 구조로 개발되었으며,  
각 영역에 적합한 기술 스택을 선택하여 협업 효율과 유지보수성을 고려하였다.

---

#### ❇️ 프론트엔드

- **React**
  - 컴포넌트 기반 구조를 활용하여 UI를 구성
  - 화면 단위와 공통 컴포넌트를 분리하여 재사용성 확보

- **JavaScript (ES6+)**
  - 최신 문법을 활용하여 가독성과 유지보수성을 향상

- **Vite**
  - 빠른 개발 서버 환경 제공
  - 빌드 및 개발 속도 개선

- **MUI (Material UI)**
  - 관리자 대시보드 및 통계 화면 구현
  - 일관된 디자인과 UI 생산성 확보

- **Axios**
  - 백엔드 API와의 HTTP 통신 처리
  - 요청/응답 로직을 분리하여 관리

- **CSS / Styled Components**
  - 컴포넌트 단위 스타일링
  - UI 구조와 스타일 책임 분리

---

#### ❇️ 백엔드

- **Java (JDK 17)**
  - 안정적인 서버 환경 구성
  - 객체 지향 기반 비즈니스 로직 구현

- **Spring Boot**
  - REST API 서버 구축
  - Controller / Service 계층 분리를 통한 구조화된 개발

- **MyBatis**
  - SQL을 XML로 관리하여 쿼리 가독성 및 유지보수성 확보
  - 복잡한 통계 및 관리자 쿼리 처리에 활용

- **Spring Validation / Exception Handling**
  - 요청 데이터 검증
  - 공통 예외 처리 구조 적용

---

#### ❇️ 데이터베이스

- **MySQL**
  - 사용자, 레시피, 커뮤니티, 관리자 데이터 저장
  - 관계형 데이터 구조를 기반으로 안정적인 데이터 관리

---

#### ❇️ 협업 및 개발 도구

- **Git & GitHub**
  - 이슈 기반 브랜치 전략 및 Pull Request 중심 협업
  - 코드 리뷰를 통한 품질 관리

- **GitHub Issues / Projects**
  - 작업 단위 관리 및 진행 상황 공유

- **Postman**
  - API 테스트 및 프론트엔드 연동 전 검증

- **Discord**
  - 팀 커뮤니케이션 및 코드 리뷰 진행

---

#### ❇️ 개발 환경

- **IDE**
  - IntelliJ IDEA (Backend)
  - VS Code (Frontend)

- **OS**
  - macOS / Windows 혼합 환경에서 개발

## 🚀 배포

본 프로젝트는 **Docker Compose**를 사용하여  
백엔드 서버 및 Redis 환경을 컨테이너 기반으로 구성하였다.  
로컬 및 서버 환경에서 동일한 방식으로 실행할 수 있도록 설정되어 있다.

---

#### ❇️ 실행 환경

- Docker
- Docker Compose
- Redis (캐시 및 세션 관리)
- RedisInsight (Redis 상태 확인용 GUI)

---

#### ❇️ 배포 및 실행 방법

 docker-compose.yml

 ✅ 관리용 명령어 모음
 1) 실행(백그라운드):          docker compose up -d
 2) 상태 확인:                docker compose ps
 3) 로그 보기:                docker compose logs -f
 4) 특정 서비스만 로그:        docker compose logs -f redis
 5) 중지(컨테이너 유지):       docker compose stop
 6) 재시작:                   docker compose restart
 7) 내리기(컨테이너/네트워크 삭제): docker compose down
 8) 내리기 + 볼륨까지 삭제(⚠️ 데이터도 삭제): docker compose down -v

 ✅ Redis 접속/테스트
 - Redis CLI 접속:            docker exec -it redis-15mintable redis-cli
 - ping 테스트:               docker exec -it redis-15mintable redis-cli ping

 ✅ RedisInsight 접속(브라우저)
 - http://localhost:5540
 - Redis 연결 URL(도커 RedisInsight 기준):
     방법 A) 컨테이너끼리: redis://redis-15mintable:6379
     방법 B) 호스트 경유: redis://host.docker.internal:6379



## 🖥 화면 구현

### ✅ 로그인
![로그인 화면](https://github.com/user-attachments/assets/49d24eed-2a26-4bbf-81ca-2b018b885af4)



